
class native Void;
class native Bool;
class native Int;
class native Float;
class native String;
class native List[$T];

fn equals(x $T, y $T) Bool {
  return x is y;
}

fn greaterThanOrEqualTo(x Int, y Int) Bool {
  return !(x < y);
}
fn greaterThan(x $T, y $T) Bool {
  return y < x;
}
fn lessThanOrEqualTo(x $T, y $T) Bool {
  return !(y < x);
}

fn repr(xs List[$T]) String {
  let str = "[";
  for (let i = 0; i < len(xs); i = i+1) {
    if (i > 0) {
      str = str + ", ";
    }
    str = str + repr(xs[i]);
  }
  str = str + "]";
  return str;
}

fn repr(x $T) String {
  return "<" + typestr($T) + " instance>";
}

fn str(x $T) String {
  return repr(x);
}

fn print(x Int) Void {
  print(str(x));
}

fn print(x $T) Void {
  print(str(x));
}

fn mallocPrimitiveError($T) Void {
  // TODO: Ideally, I'd like to have constexpr functions that I can
  // use in compile time expressions like the following:
  // #error "Cannot malloc primitive type: " + typestr($T);

  #error "Cannot malloc primitive type";
}

fn malloc(Void) Void {
  mallocPrimitiveError(Void);
}

fn malloc(Int) Int {
  mallocPrimitiveError(Int);
}

fn malloc(Float) Float {
  mallocPrimitiveError(Float);
}

fn malloc(String) String {
  mallocPrimitiveError(String);
}

fn malloc(List[$T]) List[$T] {
  mallocPrimitiveError(List[$T]);
}

//// Once better metaprogramming tools are available,
//// the following should be possible.
// fn new($T) $T {
//   #if defined(init($T)) {
//     $T t = malloc($T);
//     init(t);
//     return t;
//   } else {
//     return malloc($T);
//   }
// }
