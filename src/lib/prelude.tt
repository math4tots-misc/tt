
class native Void;
class native Bool;
class native Int;
class native Float;
class native String;

fn error(x $X) Void {
  error(repr(x));
}

fn equals(x $T, y $T) Bool {
  return x is y;
}

fn notEquals(x $T, y $T) Bool {
  return !equals(x, y);
}

fn greaterThanOrEqualTo(x Int, y Int) Bool {
  return !(x < y);
}
fn greaterThan(x $T, y $T) Bool {
  return y < x;
}
fn lessThanOrEqualTo(x $T, y $T) Bool {
  return !(y < x);
}

fn repr(x $T) String {
  return "<" + typestr($T) + " instance>";
}

fn str(x $T) String {
  return repr(x);
}

fn print(x Int) Void {
  print(str(x));
}

fn print(x $T) Void {
  print(str(x));
}

fn mallocPrimitiveError($T) Void {
  // TODO: Ideally, I'd like to have constexpr functions that I can
  // use in compile time expressions like the following:
  // #error "Cannot malloc primitive type: " + typestr($T);

  #error "Cannot malloc primitive type";
}

fn malloc(Void) Void {
  mallocPrimitiveError(Void);
}

fn malloc(Int) Int {
  mallocPrimitiveError(Int);
}

fn malloc(Float) Float {
  mallocPrimitiveError(Float);
}

fn malloc(String) String {
  mallocPrimitiveError(String);
}

//// Once better metaprogramming tools are available,
//// the following should be possible.
// fn new($T) $T {
//   #if defined(init($T)) {
//     $T t = malloc($T);
//     init(t);
//     return t;
//   } else {
//     return malloc($T);
//   }
// }


/*

fn malloc($T) $T {
  #for #var.attr in #attrsof($T) {
    x.#var.attr = #defval(x.#var.attr);
  }
  return x;
}

*/
