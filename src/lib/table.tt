// table.tt
// Like a map, but keys must be strings
// This is a poor man's Map until I can get a real Map implementation.
// ECMA2015 also doesn't offer object equality, but an implementation
// seemed simple enough so is offered here.

class abstract Table;
class native Table[$V];

fn native new(Table[$V]) Table[$V]"""
  return new Map();
"""

fn new(Table[$V], key String, val $V, ...args Args) Table[$V] {
  return new(Table[$V]).set(key, val, ...args);
}

fn set(:Method, t Table[$V], key String, val $V) Table[$V] {
  t[key] = val;
  return t;
}

fn set(:Method, t Table[$V], key String, val $V, ...args Args) Table[$V] {
  t[key] = val;
  t.set(...args);
  return t;
}

fn new(Table, key String, val $V, ...args Args) Table[$V] {
  return new(Table[$V], key, val, ...args);
}

fn native __setitem__(t Table[$V], key String, value $V) Void"""
  var_t.set(var_key, var_value);
"""

fn native __contains__(t Table[$V], key String) Bool"""
  return var_t.has(var_key);
"""

fn native __getitem__(t Table[$V], key String) $V"""
  const result = var_t.get(var_key);
  if (result === undefined) {
    throw new Error("No such key: " + var_key);
  }
  return result;
"""

fn native getListOfKeys(:Method, t Table[$V]) List[String]"""
  return Array.from(var_t.keys());
"""

fn repr(t Table[$V]) String {
  final keys = t.getListOfKeys().sort();
  let s = "{";
  for (let i = 0; i < len(keys); i++) {
    let key = keys[i];
    if (i != 0) {
      s += ", ";
    }
    s += key + ":" + repr(t[key]);
  }
  s += "}";
  return s;
}

fn __eq__(a Table[$V], b Table[$V]) Bool {
  if (len(a) != len(b)) {
    return false;
  }
  final akeys = a.getListOfKeys().sort();
  final bkeys = b.getListOfKeys().sort();
  if (akeys != bkeys) {
    return false;
  }
  for (let i = 0; i < len(akeys); i++) {
    final key = akeys[i];
    if (a[key] != b[key]) {
      return false;
    }
  }
  return true;
}

fn native discard(:Method, t Table[$V], key String) Void"""
  var_t.delete(var_key);
"""

fn native len(t Table[$V]) Int"""
  return var_t.size;
"""
