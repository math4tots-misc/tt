
fn main() Void {
  //// Basic sanity checks
  {
    assert(true);
    assertFalse(false);
    assertFalse(!true);

    assert(1 == 1);
    assertFalse(1 == 2);
    assertFalse(1 != 1);
    assert(1 != 2);

    assert(2 + 2 == 4);
    assertEqual(2 + 2, 4);
    assertEqual(repr(24), "24");

    assertEqual("hi", "hi");
  }

  //// String literal
  {
    """
    Make sure that strings can be used as statement-level comments.
    """;
    assertEqual("\\" + "n", "\\n");
    assertEqual("\\" + "n", r"\n");
    assert("\\" + "n" != "\n");
  }

  //// Default variable values.
  {
    let i Int;
    assertEqual(i, 0);

    let s String;
    assertEqual(s, "");

    assertEqual(globalInt, 0);
    assertEqual(globalFloat, 0.0);
  }

  //// Class, get/set attributes
  {
    final sample = malloc(Sample[Int]);
    assertEqual(sample.t, 0);  // default value
    sample.t = 15;
    assertEqual(sample.t, 15);
  }

  //// Vararg functions
  {
    assertEqual(sum(1, 2, 3), 6);
    assertEqual(concatTypenames(Int, Float, String), "Int,Float,String");
    assertEqual(makeList(5, 6, 7, 8), [5, 6, 7, 8]);
  }

  //// Static blocks
  {
    assertEqual(valueChangedByStaticBlock, "new value");
    assertEqual(
      valueChangedByNativeStaticBlock,
      "new value set by native static block");
  }

  //// Tuple
  {
    assertEqual(tuple(1, "hi"), tuple(1, "hi"));
    assertFalse(tuple(1, "hi") == tuple(1, "hix"));

    let t = tuple(1.0, 2, "world");
    assertEqual(typestr(t), "Tuple[Float,Int,String]");

    assertEqual(t.x0, 1.0);
    assertEqual(t.x1, 2);
    assertEqual(t.x2, "world");

    t.x0 = 5.0;
    assertEqual(t.x0, 5.0);
  }

  //// Lambda
  {
    final f = fn(a Int, b Int) {
      return "a + b = " + str(a + b);
    };
    assertEqual(repr(f), "<Lambda[String,Int,Int] instance>");
    assertEqual(call(f, 5, 7), "a + b = 12");

    final g = makeLambda(Int, Float, String);
    assertEqual(repr(g), "<Lambda[Int,Int,Float,String] instance>");
    assertEqual(call(g, 0, 0.0, ""), 5);
  }

  print("Tests pass!");
}

class Sample[$T] {
  let t $T;
}

let globalInt Int;
let globalFloat Float;

fn concatTypenames($X) String {
  return typestr($X);
}

fn concatTypenames($X, ...Rest) String {
  return typestr($X) + "," + concatTypenames(...Rest);
}

fn sum(x Int) Int {
  return x;
}

fn sum(x Int, ...args Args) Int {
  return x + sum(...args);
}

fn makeList(x Int, ...args Args) List[Int] {
  return [x, ...args];
}

let valueChangedByStaticBlock = "hello world";
let valueChangedByNativeStaticBlock = "hello world";

static {
  let varThatShouldNotClashWithOtherStaticBlock = 77;

  assertEqual(valueChangedByStaticBlock, "hello world");
  valueChangedByStaticBlock = "new value";
}

static {
  let varThatShouldNotClashWithOtherStaticBlock = 88;
}

static native """
  var_valueChangedByNativeStaticBlock =
      "new value set by native static block";
"""

fn makeLambda(...Args) Lambda[Int, ...Args] {
  return fn(...args Args) {
    return 5;
  };
}
