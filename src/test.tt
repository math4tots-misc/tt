
fn main() Void {
  //// Basic sanity checks
  {
    assert(true);
    assertFalse(false);
    assertFalse(!true);

    assert(1 == 1);
    assertFalse(1 == 2);
    assertFalse(1 != 1);
    assert(1 != 2);

    assert(2 + 2 == 4);
    assertEqual(2 + 2, 4);
    assertEqual(repr(24), "24");

    assertEqual("hi", "hi");
  }

  //// is, is not, is null, is not null
  {
    let x = malloc(Sample[Int]);
    let y = x;
    let z = malloc(Sample[Int]);
    assert(x is x);
    assert(x is y);
    assert(x is not z);
    assert(x is not null);
    assert(y is not null);
    assert(z is not null);

    let a Sample[Int];
    assert(a is null);
  }

  //// String literal
  {
    """
    Make sure that strings can be used as statement-level comments.
    """;
    assertEqual("\\" + "n", "\\n");
    assertEqual("\\" + "n", r"\n");
    assert("\\" + "n" != "\n");
  }

  //// Default variable values.
  {
    let i Int;
    assertEqual(i, 0);

    let s String;
    assertEqual(s, "");

    assertEqual(globalInt, 0);
    assertEqual(globalFloat, 0.0);
  }

  //// Class, get/set attributes
  {
    final sample = malloc(Sample[Int]);
    assertEqual(sample.t, 0);  // default value
    sample.t = 15;
    assertEqual(sample.t, 15);
  }

  //// Vararg functions
  {
    assertEqual(sum(1, 2, 3), 6);
    assertEqual(concatTypenames(Int, Float, String), "Int,Float,String");
    assertEqual(makeList(5, 6, 7, 8), [5, 6, 7, 8]);
  }

  //// Static blocks
  {
    assertEqual(valueChangedByStaticBlock, "new value");
    assertEqual(
      valueChangedByNativeStaticBlock,
      "new value set by native static block");
  }

  //// Tuple
  {
    assertEqual(tuple(1, "hi"), tuple(1, "hi"));
    assertFalse(tuple(1, "hi") == tuple(1, "hix"));

    let t = tuple(1.0, 2, "world");
    assertEqual(typestr(t), "Tuple[Float,Int,String]");

    assertEqual(t.x0, 1.0);
    assertEqual(t.x1, 2);
    assertEqual(t.x2, "world");

    t.x0 = 5.0;
    assertEqual(t.x0, 5.0);
  }

  //// Lambda
  {
    final f = fn(a Int, b Int) {
      return "a + b = " + str(a + b);
    };
    assertEqual(repr(f), "<Lambda[String,Int,Int] instance>");
    assertEqual(call(f, 5, 7), "a + b = 12");

    final g = makeLambda(Int, Float, String);
    assertEqual(repr(g), "<Lambda[Int,Int,Float,String] instance>");
    assertEqual(call(g, 0, 0.0, ""), 5);
  }

  //// Async
  {
    startAsync(asyncFunction());
  }

  //// Table
  {
    final table = new(Table[Int]);
    assert("x" not in table);
    assertEqual(len(table), 0);
    table["x"] = 5;
    assertEqual(table["x"], 5);
    assertEqual(len(table), 1);
    assertEqual(table, new(Table[Int], "x", 5));
    assertEqual(str(table), '{x:5}');
    assert("x" in table);
    table.discard("x");
    assert("x" not in table);
    assertEqual(len(table), 0);
  }

  //// List
  {
    let xs = new(List[Int]);
    push(:Method, xs, 5);
    assertEqual(xs, [5]);
    push(:Method, xs, 6);
    assertEqual(xs, [5, 6]);
    assertEqual(xs[1], 6);
    assertEqual(pop(:Method, xs), 6);
    assertEqual(xs, [5]);

    let ys = ["a", "z", "b", "e", "d"];
    assert(ys is ys.sort());
    assertEqual(ys, ["a", "b", "d", "e", "z"]);
  }

  //// Method syntax
  {
    // syntactic sugar on function calls
    // push(:Method, xs, 5) is semantically equivalent to xs.push(5)
    let xs = new(List[String]).push("a").push("b");
    assertEqual(xs, ["a", "b"]);
    xs.push("cc");
    assertEqual(xs, ["a", "b", "cc"]);
    assertEqual(xs.pop(), "cc");
    assertEqual(xs, ["a", "b"]);
  }

  //// String += operator
  {
    let s = "a";
    s += "bb";
    assertEqual(s, "abb");
    s += "c";
    assertEqual(s, "abbc");
  }

  //// int/float
  {
    let i = 0;
    assertEqual(i, 0);
    i++;
    assertEqual(i, 1);
    i++;
    assertEqual(i, 2);
    i--;
    assertEqual(i, 1);
    i--;
    assertEqual(i, 0);
    i--;
    assertEqual(i, -1);

    assertEqual(5 - 3, 2);

    assertEqual(int(5.7), 5);
  }

  //// negative int
  {
    assertEqual(0 - 5, -5);
  }

  //// String repr
  {
    assertEqual(repr("hello world!"), '"hello world!"');
    assertEqual(repr("\n"), r'"\n"');
    assertEqual(repr("\\"), r'"\\"');
  }

  //// __mod__(Int,Int)
  {
    assertEqual(5 % 2, 1);
    assertEqual(7 % 3, 1);
    assertEqual(10 % 3, 1);
    assertEqual(12 % 3, 0);
  }

  //// while statements
  {
    let i = 0;
    while (i < 10) {
      i++;
    }
    assertEqual(i, 10);

    i = 0;
    while (true) {
      if (i > 5) {
        break;
      }
      i++;
    }
    assertEqual(i, 6);

    let items = new(List[Int]);
    for (let i = 0; i < 5; i++) {
      if (i%2 == 0) {
        continue;
      }
      items.push(i);
    }
    assertEqual(items, [1, 3]);
  }

  //// async lambda functions
  {
    final someList = new(List[Int]);
    startAsync(async() {
      assertEqual(someList, new(List[Int]));
      await asyncSleep(10);
      assertEqual(someList, [151]);
    });
    startAsync(async() {
      someList.push(151);
    });
  }

  //// async queue
  {
    final queue = new(AsyncQueue[Int]);
    startAsync(async() {
      final item = await queue.asyncPop();
      assertEqual(item, 244);
    });
    startAsync(async() {
      await asyncSleep(50);
      queue.push(244);
    });
  }

  //// Maybe
  {
    let a = new(Maybe[Int]);
    assert(a.isNothing());
    assertEqual(a, new(Maybe[Int]));
    assertEqual(repr(a), "new(Maybe[Int])");
    a = new(Maybe, 5);
    assertFalse(a.isNothing());
    assertEqual(a.get(), 5);
    assertEqual(a, new(Maybe, 5));
    assertFalse(a == new(Maybe, 3));
    assertEqual(repr(a), "new(Maybe,5)");
  }

  print("synchronous main finished!");
}

class Sample[$T] {
  let t $T;
}

let globalInt Int;
let globalFloat Float;

fn concatTypenames($X) String {
  return typestr($X);
}

fn concatTypenames($X, ...Rest) String {
  return typestr($X) + "," + concatTypenames(...Rest);
}

fn sum(x Int) Int {
  return x;
}

fn sum(x Int, ...args Args) Int {
  return x + sum(...args);
}

fn makeList(x Int, ...args Args) List[Int] {
  return [x, ...args];
}

let valueChangedByStaticBlock = "hello world";
let valueChangedByNativeStaticBlock = "hello world";

static {
  let varThatShouldNotClashWithOtherStaticBlock = 77;

  assertEqual(valueChangedByStaticBlock, "hello world");
  valueChangedByStaticBlock = "new value";
}

static {
  let varThatShouldNotClashWithOtherStaticBlock = 88;
}

static native """
  var_valueChangedByNativeStaticBlock =
      "new value set by native static block";
"""

fn makeLambda(...Args) Lambda[Int, ...Args] {
  return fn(...args Args) {
    return 5;
  };
}

fn async asyncFunction() Void {
  print("I'm at the beginning of asyncFunction");
  await asyncSleep(1000);

  // asyncSleep(1000);
  """Uncommenting the above line should produce a message like the
  following:

  Error: await or runAsync not used on some promise(s)
  Most recent call last:
    main()              in 'test.tt'           line 97
    asyncFunction()     in 'test.tt'           line 158
  """;

  // error("Hoi");
  // Uncommenting the above line should show a nice stack trace like:
  // Most recent call last:
  // main()              in 'test.tt'           line 97
  // asyncFunction()     in 'test.tt'           line 158

  print("I'm at the end of asyncFunction (after await asyncSleep)");
}
