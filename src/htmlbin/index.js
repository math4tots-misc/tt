$(document).ready(() => {// Autogenerated by the tt->js compiler
(function() {
"use strict";
//// Begin native prelude
function pop(stack, value) {
  stack.pop();
  return value;
}
function padstr(str, len) {
  if (str.length < len) {
    return str + " ".repeat(len-str.length);
  } else {
    return str;
  }
}
function getStackTraceMessage(stack) {
  let message = "\nMost recent call last:";
  for (const tag of stack) {
    const [funcname, uri, lineno] = tagList[tag].split("@");
    message += "\n  " + padstr(funcname, 20) +
               "in " + padstr("'" + uri + "'", 20) +
               "line " + padstr(lineno, 5);
  }
  return message;
}
function tryAndCatch(f, stack) {
  stack = stack || makeStack();
  try {
    f(stack);
  } catch (e) {
    if (stack.length > 0) {
      console.error(getStackTraceMessage(stack).trim());
    }
    throw e;
  } finally {
    deleteStack(stack);
  }
}
function asyncf(unwrappedGenerator) {
  function* generator() {
    const oldStack = arguments[0];
    // When starting a new async context, we need to make a copy of the
    // old stack, since there could potentially be multiple async contexts
    // started before being 'await'ed on.
    const stack = makeStack(oldStack);
    const args = [stack];
    for (let i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    try {
      return yield* unwrappedGenerator.apply(null, args);
    } catch(e) {
      // Keep a copy of the stack so that whoever catches it knows where
      // it came from.
      // I thought about modifying the oldStack, but that would involve
      // knowing exactly when the caller is going to resume.
      // when we reject, we don't know if 'then' or 'catch' has been called
      // on the promise yet, so there might actually be other stuff going
      // on clobbering the stack before dealing with this.
      if (!e.ttstackSnapshot) {
        e.ttstackSnapshot = Array.from(newStack);
      }
      throw e;
    } finally {
      deleteStack(stack);
    }
  }
  return function(oldStack) {
    const generatorObject = generator.apply(null, arguments);
    return newPromise(oldStack, (resolve, reject) => {
      asyncfHelper(generatorObject, resolve, reject);
    });
  }
}
function asyncfHelper(generatorObject, resolve, reject, val, thr) {
  try {
    const {value, done} =
        thr ? generatorObject.throw(val) : generatorObject.next(val);
    if (done) {
      resolve(value);
    } else {
      markPromiseAwaited(value);
      value.then(val => {
        finalizePromise(value);
        asyncfHelper(generatorObject, resolve, reject, val);
      }).catch(err => {
        finalizePromise(value);
        asyncfHelper(generatorObject, resolve, reject, err, true);
      });
    }
  } catch (e) {
    reject(e);
  }
}

/**
 * Maps each promise to a snapshot of the stack when it was created
 * @type{!Map<!Promise, !Array<number>>}
 */
const promiseStackSnapshot = new Map();

function getStackSnapshotOfPromise(promise) {
  if (!promiseStackSnapshot.has(promise)) {
    throw new Error("Unregistered promise: " + promise);
  }
  return promiseStackSnapshot.get(promise);
}
function addStackSnapshotForPromise(stack, promise) {
  promiseStackSnapshot.set(promise, Array.from(stack));
}
function removeStackSnapshotForPromise(promise) {
  promiseStackSnapshot.delete(promise);
}

/**
 * Maps each stack to a set of promises created while that stack was
 * active.
 * @type{!Map<!Array<number>, !Set<!Promise>>}
 */
const promisePool = new Map();

function initializePromisePool(stack) {
  promisePool.set(stack, new Set());
}
function finalizePromisePool(stack) {
  const remainingPromises = promisePool.get(stack);
  if (remainingPromises.size > 0) {
    let message = "await or runAsync not used on some promise(s)";
    for (const promise of remainingPromises) {
      message +=
          getStackTraceMessage(getStackSnapshotOfPromise(promise));
    }
    throw new Error(message);
  }
}
function addToPromisePool(stack, promise) {
  promisePool.get(stack).add(promise);
}
function removeFromPromisePool(promise) {
  promisePool.get(promiseToStackMap.get(promise)).delete(promise);
}

/**
 * @type{!Map<!Promise, !Array<number>>}
 */
const promiseToStackMap = new Map();

// let nextPromiseId = 1;
function newPromise(stack, resolver) {
  const promise = new Promise(resolver);
  promiseToStackMap.set(promise, stack);
  // const id = nextPromiseId++;
  // promise.id = id;
  // console.error("newPromise id = " + id + " stack.id = " + stack.id);
  addToPromisePool(stack, promise);
  addStackSnapshotForPromise(stack, promise);
  return promise;
}
function markPromiseAwaited(promise) {
  // console.error("markPromiseAwaited id = " + promise.id);
  removeFromPromisePool(promise);
}
function finalizePromise(promise) {
  // console.error("finalizePromise id = " + promise.id);
  promiseToStackMap.delete(promise);
  removeStackSnapshotForPromise(promise);
}

// let nextStackId = 1;
function makeStack(oldStack) {
  const stack = oldStack ? Array.from(oldStack) : [];
  initializePromisePool(stack);
  // const id = nextStackId++;
  // stack.id = id;
  // console.error("makeStack id = " + id);
  return stack;
}
function deleteStack(stack) {
  // console.error("deleteStack id = " + stack.id);
  finalizePromisePool(stack);
}

//// End native prelude
// --- global variable declarations ---
// --- function definitions ---

function main__$1(stack) /*Void*/
{
  (stack.push(0),pop(stack,print__$2(stack,"This should appear in the browser\'s console")));
  let var_body = new__$3(stack,undefined,"body");
  let var_layout = new__$4(stack,undefined);
  let var_centerPane = new__$3(stack,undefined,"<div></div>");
  (stack.push(1),pop(stack,setText__$5(stack,var_centerPane,"I\'m the center pane!")));
  (stack.push(2),pop(stack,setCenter__$6(stack,var_layout,var_centerPane)));
  let var_southPane = new__$3(stack,undefined,"<div></div>");
  (stack.push(3),pop(stack,setText__$5(stack,var_southPane,"I\'m the south pane!")));
  (stack.push(4),pop(stack,setSouth__$7(stack,var_layout,var_southPane)));
  let var_eastPane = new__$3(stack,undefined,"<div></div>");
  (stack.push(5),pop(stack,setText__$5(stack,var_eastPane,"I\'m the east pane!")));
  (stack.push(6),pop(stack,setEast__$8(stack,var_layout,var_eastPane)));
  (stack.push(7),pop(stack,append__$10(stack,var_body,getJquery__$9(stack,var_layout))));
  (stack.push(8),pop(stack,setup__$11(stack,var_layout)));
}

// native function: print(String)Void
function print__$2(stack, var_x/*String*/) /*Void*/
{
  console.log(var_x);

}

// native function: new(Jquery,String)Jquery
function new__$3(stack, var_null/*Jquery*/, var_selector/*String*/) /*Jquery*/
{
  return $(var_selector);

}

// native function: new(JqueryLayout)JqueryLayout
function new__$4(stack, var_null/*JqueryLayout*/) /*JqueryLayout*/
{
  const jq = $("<div></div>");
  jq.css("height", "100%");
  return {
    jquery: jq,
    layout: null,
  };

}

// native function: setText(Jquery,String)Void
function setText__$5(stack, var_jq/*Jquery*/, var_text/*String*/) /*Void*/
{
  var_jq.text(var_text);

}

function setCenter__$6(stack, var_jql/*JqueryLayout*/, var_element/*Jquery*/) /*Void*/
{
  (stack.push(9),pop(stack,setPane__$12(stack,var_jql,"center",var_element)));
}

function setSouth__$7(stack, var_jql/*JqueryLayout*/, var_element/*Jquery*/) /*Void*/
{
  (stack.push(10),pop(stack,setPane__$12(stack,var_jql,"south",var_element)));
}

function setEast__$8(stack, var_jql/*JqueryLayout*/, var_element/*Jquery*/) /*Void*/
{
  (stack.push(11),pop(stack,setPane__$12(stack,var_jql,"east",var_element)));
}

// native function: getJquery(JqueryLayout)Jquery
function getJquery__$9(stack, var_jql/*JqueryLayout*/) /*Jquery*/
{
  return var_jql.jquery;

}

// native function: append(Jquery,Jquery)Void
function append__$10(stack, var_jq/*Jquery*/, var_child/*Jquery*/) /*Void*/
{
  var_jq.append(var_child);

}

// native function: setup(JqueryLayout)Void
function setup__$11(stack, var_jql/*JqueryLayout*/) /*Void*/
{
  const jq = var_jql.jquery;
  var_jql.layout = jq.layout({applyDefaultStyles: true});

}

// native function: setPane(JqueryLayout,String,Jquery)Void
function setPane__$12(stack, var_jql/*JqueryLayout*/, var_dir/*String*/, var_element/*Jquery*/) /*Void*/
{
  const dirs = ["center", "north", "south", "west", "east"];
  if (dirs.indexOf(var_dir) === -1) {
    throw new Error(
        var_dir + " is not a valid direction, must be one of " +
        dirs.join(", "));
  }

  const cls = "ui-layout-" + var_dir;

  var_element.addClass(cls);
  const existingCenter = var_jql.jquery.find("." + cls);
  if (existingCenter.length === 0) {
    var_jql.jquery.append(var_element);
  } else {
    existingCenter.replaceWith(var_element);
  }

}
// --- tag list, for generating helpful stack traces ---
const tagList = ["main()@htmlsrc\\index.tt@3","main()@htmlsrc\\index.tt@10","main()@htmlsrc\\index.tt@11","main()@htmlsrc\\index.tt@14","main()@htmlsrc\\index.tt@15","main()@htmlsrc\\index.tt@18","main()@htmlsrc\\index.tt@19","main()@htmlsrc\\index.tt@22","main()@htmlsrc\\index.tt@25","setCenter(JqueryLayout,Jquery)@htmllib\\layout.tt@27","setSouth(JqueryLayout,Jquery)@htmllib\\layout.tt@35","setEast(JqueryLayout,Jquery)@htmllib\\layout.tt@43"];
tryAndCatch(stack => {
// --- call all the static stuff ---
// --- finally call main ---
main__$1(stack);
});
})();});
